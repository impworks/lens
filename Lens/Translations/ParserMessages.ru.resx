<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArgTypeExpected" xml:space="preserve">
    <value>LE2001: Ожидается тип аргумента!</value>
  </data>
  <data name="ArgumentsExpected" xml:space="preserve">
    <value>LE2003: Ожидаются аргументы для вызова метода!</value>
  </data>
  <data name="ArrayItem" xml:space="preserve">
    <value>LE2004: Массив должен содержать по крайней мере один элемент!</value>
  </data>
  <data name="AssignExpressionExpected" xml:space="preserve">
    <value>LE2005: Ожидается присваиваемое выражение!</value>
  </data>
  <data name="AssignLvalueExpected" xml:space="preserve">
    <value>LE2006: Выражению слева нельзя присвоить новое значение!</value>
  </data>
  <data name="CatchExpected" xml:space="preserve">
    <value>LE2007: Ожидается блок catch!</value>
  </data>
  <data name="ClosingBraceNewLine" xml:space="preserve">
    <value>LE2008: Закрывающая скобка должна располагаться на следующей строке!</value>
  </data>
  <data name="CodeBlockExpected" xml:space="preserve">
    <value>LE2009: Ожидается блок кода!</value>
  </data>
  <data name="ConditionBlockExpected" xml:space="preserve">
    <value>LE2010: Ожидается блок условия!</value>
  </data>
  <data name="ConditionExpected" xml:space="preserve">
    <value>LE2011: Ожидается условие!</value>
  </data>
  <data name="ConditionExpressionExpected" xml:space="preserve">
    <value>LE2012: Ожидается выражение условия!</value>
  </data>
  <data name="DictionaryItem" xml:space="preserve">
    <value>LE2013: Словарь должен содержать по крайней мере один элемент!</value>
  </data>
  <data name="DictionaryKeyExpected" xml:space="preserve">
    <value>LE2014: Ожидается ключ для записи словаря!</value>
  </data>
  <data name="DictionaryValueExpected" xml:space="preserve">
    <value>LE2015: Ожидается значение для записи словаря!</value>
  </data>
  <data name="ExceptionHandlerExpected" xml:space="preserve">
    <value>LE2016: Ожидается блок-обработчик исключения!</value>
  </data>
  <data name="ExceptionTypeExpected" xml:space="preserve">
    <value>LE2017: Ожидается тип обрабатываемого исключения!</value>
  </data>
  <data name="ExpressionExpected" xml:space="preserve">
    <value>LE2018: Ожидается выражение!</value>
  </data>
  <data name="FunctionBodyExpected" xml:space="preserve">
    <value>LE2019: Ожидается тело функции!</value>
  </data>
  <data name="FunctionDefExpected" xml:space="preserve">
    <value>LE2020: Ожидается объявление функции!</value>
  </data>
  <data name="FunctionIdentifierExpected" xml:space="preserve">
    <value>LE2021: Имя функции должно быть идентификатором!</value>
  </data>
  <data name="FunctionReturnExpected" xml:space="preserve">
    <value>LE2022: Ожидается тип возвращаемого значения функции!</value>
  </data>
  <data name="IdentifierExpected" xml:space="preserve">
    <value>LE2023: Ожидается идентификатор!</value>
  </data>
  <data name="IndexExpressionExpected" xml:space="preserve">
    <value>LE2024: Ожидается выражение-индекс!</value>
  </data>
  <data name="InitExpressionExpected" xml:space="preserve">
    <value>LE2025: Ожидается инициализирующее выражение!</value>
  </data>
  <data name="InitExpressionOrTypeExpected" xml:space="preserve">
    <value>LE2026: Ожидается инициализирующее выражение или тип переменной!</value>
  </data>
  <data name="InitExpressionSeparatorExpected" xml:space="preserve">
    <value>LE2027: Инициализирующие выражения должны располагаться на отдельных строках!</value>
  </data>
  <data name="InitializerIndentExprected" xml:space="preserve">
    <value>LE2028: Инициализирующие выражения должны быть выделены отступом!</value>
  </data>
  <data name="InvalidDouble" xml:space="preserve">
    <value>LE2029: Значение '{0}' не является допустимым дробным числом!</value>
  </data>
  <data name="InvalidInteger" xml:space="preserve">
    <value>LE2030: Значение '{0}' не является допустимым целым числом!</value>
  </data>
  <data name="InvokePassSeparatorExpected" xml:space="preserve">
    <value>LE2031: Выражения передачи значения должны располагаться на отдельных строках!</value>
  </data>
  <data name="ListItem" xml:space="preserve">
    <value>LE2032: Список должен содержать по крайней мере один элемент!</value>
  </data>
  <data name="LoopBodyExpected" xml:space="preserve">
    <value>LE2033: Ожидается тело цикла!</value>
  </data>
  <data name="LoopExpressionExpected" xml:space="preserve">
    <value>LE2034: Ожидается выражение-тело цикла!</value>
  </data>
  <data name="MemberNameExpected" xml:space="preserve">
    <value>LE2035: Ожидается имя поля!</value>
  </data>
  <data name="NamespaceExpected" xml:space="preserve">
    <value>LE2037: Ожидается пространство имен!</value>
  </data>
  <data name="NewlineSeparatorExpected" xml:space="preserve">
    <value>LE2038: Выражения должны располагаться на новых строках!</value>
  </data>
  <data name="RangeEndExpected" xml:space="preserve">
    <value>LE2039: Ожидается выражение-конец диапазона!</value>
  </data>
  <data name="RecordFieldIdentifierExpected" xml:space="preserve">
    <value>LE2040: Имя поля записи должно быть идентификатором!</value>
  </data>
  <data name="RecordFieldTypeExpected" xml:space="preserve">
    <value>LE2041: Ожидается тип поля записи!</value>
  </data>
  <data name="RecordIdentifierExpected" xml:space="preserve">
    <value>LE2042: Название записи должно быть идентификатором!</value>
  </data>
  <data name="RecordIndentExpected" xml:space="preserve">
    <value>LE2043: Описание записи должно быть выделено отступами!</value>
  </data>
  <data name="RecordSeparatorExpected" xml:space="preserve">
    <value>LE2044: Поля записи должны располагаться на отдельных строках!</value>
  </data>
  <data name="RefLvalueExpected" xml:space="preserve">
    <value>LE2045: Модификатор 'ref' требует указания переменной, поля или индекса массива!</value>
  </data>
  <data name="SequenceExpected" xml:space="preserve">
    <value>LE2046: Ожидается перечислимое выражение!</value>
  </data>
  <data name="SymbolExpected" xml:space="preserve">
    <value>LE2047: Ожидается '{0}'!</value>
  </data>
  <data name="TryBlockExpected" xml:space="preserve">
    <value>LE2048: Ожидается блок try!</value>
  </data>
  <data name="TupleItem" xml:space="preserve">
    <value>LE2049: Кортеж должен содержать по крайней мере один элемент!</value>
  </data>
  <data name="TypeArgumentExpected" xml:space="preserve">
    <value>LE2050: Ожидается аргумент обобщенного типа!</value>
  </data>
  <data name="TypeIdentifierExpected" xml:space="preserve">
    <value>LE2051: Имя типа должно быть идентификатором!</value>
  </data>
  <data name="TypeIndentExpected" xml:space="preserve">
    <value>LE2052: Описание типа должно быть выделено отступами!</value>
  </data>
  <data name="TypeLabelIdentifierExpected" xml:space="preserve">
    <value>LE2053: Имя метки типа должно быть идентификатором!</value>
  </data>
  <data name="TypeLabelTagTypeExpected" xml:space="preserve">
    <value>LE2054: Ожидается тип связанного с меткой выражения!</value>
  </data>
  <data name="TypeSeparatorExpected" xml:space="preserve">
    <value>LE2055: Метки должны располагаться на отдельных строках!</value>
  </data>
  <data name="TypeSignatureExpected" xml:space="preserve">
    <value>LE2056: Ожидается подпись типа!</value>
  </data>
  <data name="UnknownStatement" xml:space="preserve">
    <value>LE2057: Неизвестный тип выражения!</value>
  </data>
  <data name="VariadicByRef" xml:space="preserve">
    <value>LE2060: Нельзя пометить аргумент, передающийся по ссылке, модификатором '...'!</value>
  </data>
  <data name="VarIdentifierExpected" xml:space="preserve">
    <value>LE2061: Имя переменной должно быть идентификатором!</value>
  </data>
  <data name="VarTypeExpected" xml:space="preserve">
    <value>LE2062: Ожидается подпись типа переменной!</value>
  </data>
  <data name="UsingBodyExpected" xml:space="preserve">
    <value>LE2058: Ожидается тело блока управления ресурсом!</value>
  </data>
  <data name="UsingExpressionExpected" xml:space="preserve">
    <value>LE2059: Ожидается выражение-тело блока управления ресурсом!</value>
  </data>
  <data name="ArgumentPassIndentExpected" xml:space="preserve">
    <value>LE2002: Перед выражением '&lt;|' требуется отступ!</value>
  </data>
  <data name="MethodPassIndentExpected" xml:space="preserve">
    <value>LE2036: Перед выражением '|&gt;' требуется отступ!</value>
  </data>
  <data name="InvalidFloat" xml:space="preserve">
    <value>LE2063: Значение '{0}' не является допустимым дробным числом!</value>
  </data>
  <data name="InvalidDecimal" xml:space="preserve">
    <value>LE2065: Значение '{0}' не является допустимым десятичным числом!</value>
  </data>
  <data name="InvalidLong" xml:space="preserve">
    <value>LE2064: Значение '{0}' не является допустимым целым числом!</value>
  </data>
  <data name="MatchExpressionExpected" xml:space="preserve">
    <value>LE2066: Ожидается выражение для сопоставления с образцом!</value>
  </data>
  <data name="MatchIndentExpected" xml:space="preserve">
    <value>LE2068: Правила сопоставления должны быть выделены отступами!</value>
  </data>
  <data name="MatchRuleExpected" xml:space="preserve">
    <value>LE2069: Ожидается правило сопоставления!</value>
  </data>
  <data name="WhenGuardExpressionExpected" xml:space="preserve">
    <value>LE2067: Ожидается проверочное выражение!</value>
  </data>
</root>