<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArgumentTypeMismatch" xml:space="preserve">
    <value>LE3001: Невозможно использовать выражения типа '{0}' в качестве значения параметра типа '{1}'!</value>
  </data>
  <data name="ArrayElementTypeMismatch" xml:space="preserve">
    <value>LE3002: Невозможно добавить объект типа '{0}' в массив типа '{1}'!</value>
  </data>
  <data name="ArrayEmpty" xml:space="preserve">
    <value>LE3003: Инициализатор массива должен содержать хотя бы один элемент! Для создания пустых массивов воспользуйтесь явным конструктором.</value>
  </data>
  <data name="ArrayTypeUnknown" xml:space="preserve">
    <value>LE3005: Тип массива не может быть выведен! Воспользуйтесь операцией приведения типов.</value>
  </data>
  <data name="CallableTooManyArguments" xml:space="preserve">
    <value>LE3006: Невозможно создать делегат из метода, принимающего более 16 аргументов.</value>
  </data>
  <data name="CastDelegateArgTypesMismatch" xml:space="preserve">
    <value>LE3007: У делегатов '{0}' и '{1}' не совпадают аргументы!</value>
  </data>
  <data name="CastDelegateReturnTypesMismatch" xml:space="preserve">
    <value>LE3008: У делегатов '{0}' и '{1}' не совпадают возвращаемые значения!</value>
  </data>
  <data name="CastNullValueType" xml:space="preserve">
    <value>LE3009: Невозможно привести выражение null к типу '{0}', поскольку он передается по значению!</value>
  </data>
  <data name="CastTypesMismatch" xml:space="preserve">
    <value>LE3010: Невозможно привести объект типа '{0}' к типу '{1}'!</value>
  </data>
  <data name="CatchClauseUnreachable" xml:space="preserve">
    <value>LE3011: Это выражение catch недостижимо, поскольку исключения типа '{0}' будут перехвачены выше как наследники типа '{1}'!</value>
  </data>
  <data name="CatchTypeDuplicate" xml:space="preserve">
    <value>LE3012: Тип '{0}' уже был использован в выражении catch текущего блока try!</value>
  </data>
  <data name="CatchTypeNotException" xml:space="preserve">
    <value>LE3013: Тип '{0}' не может быть использован в выражении catch, поскольку он не наследуется от System.Exception!</value>
  </data>
  <data name="ClosureImplicit" xml:space="preserve">
    <value>LE3014: Невозможно использовать неявную переменную в замыкании!</value>
  </data>
  <data name="ClosureRef" xml:space="preserve">
    <value>LE3015: Невозможно использовать в замыкании аргумент '{0}', поскольку он передается по ссылке!</value>
  </data>
  <data name="CodeBlockEmpty" xml:space="preserve">
    <value>LE3016: Блок кода должен содержать хотя бы одно выражение!</value>
  </data>
  <data name="CodeBlockLastVar" xml:space="preserve">
    <value>LE3017: Объявление переменной или константы не может быть последним выражением в блоке!</value>
  </data>
  <data name="ConditionInconsistentTyping" xml:space="preserve">
    <value>LE3018: Невозможно определить общий тип для ветвей условия! Типы выражений -  '{0}' и '{1}'.</value>
  </data>
  <data name="ConditionTypeMismatch" xml:space="preserve">
    <value>LE3019: Выражение типа '{0}' нельзя использовать в качестве условия, поскольку оно не приводится к типу boolean!</value>
  </data>
  <data name="ConstantByRef" xml:space="preserve">
    <value>LE3020: Константы нельзя передавать в функции по ссылке!</value>
  </data>
  <data name="ConstantDivisionByZero" xml:space="preserve">
    <value>LE3021: Деление на ноль!</value>
  </data>
  <data name="ConstantOverflow" xml:space="preserve">
    <value>LE3022: Результат выражения-константы превышает допустимое максимальное значение типа!</value>
  </data>
  <data name="ConstructorStatic" xml:space="preserve">
    <value>LE3023: Конструктор не может быть статическим!</value>
  </data>
  <data name="ContextNotFound" xml:space="preserve">
    <value>LE3024: Контекст #{0} не существует!</value>
  </data>
  <data name="ContextUnregistered" xml:space="preserve">
    <value>LE3025: Контекст #{0} был освобожден!</value>
  </data>
  <data name="DelegateArgumentsCountMismatch" xml:space="preserve">
    <value>LE3026: Вызов делегата типа '{0}' требует {1} аргументов, а передано {2}!</value>
  </data>
  <data name="DelegatesNotCombinable" xml:space="preserve">
    <value>LE3027: Невозможно применить композицию к делегатам типов '{0}' и '{1}', поскольку их подписи несовместимы!</value>
  </data>
  <data name="DictionaryEmpty" xml:space="preserve">
    <value>LE3028: Инициализатор словаря должен содержать хотя бы один элемент! Для создания пустых словарей воспользуйтесь явным конструктором.</value>
  </data>
  <data name="DictionaryKeyTypeMismatch" xml:space="preserve">
    <value>LE3029: Невозможно добавить ключ типа '{0}' в Dictionary&lt;{1}, {2}&gt;!</value>
  </data>
  <data name="DictionaryTypeUnknown" xml:space="preserve">
    <value>LE3030: Тип словаря не может быть выведен! Воспользуйтесь операцией приведения типов.</value>
  </data>
  <data name="DictionaryValueTypeMismatch" xml:space="preserve">
    <value>LE3031: Невозможно добавить значение типа '{0}' в Dictionary&lt;{1}, {2}&gt;!</value>
  </data>
  <data name="DynamicMemberFromStaticContext" xml:space="preserve">
    <value>LE3032: Невозможно получить доступ к '{0}.{1}' из статического контекста!</value>
  </data>
  <data name="ExpressionNull" xml:space="preserve">
    <value>LE3034: Тип выражения не может быть выведен! Воспользуйтесь операцией приведения типов.</value>
  </data>
  <data name="ExpressionVoid" xml:space="preserve">
    <value>LE3035: Требуется выражение, возвращающее значение!</value>
  </data>
  <data name="ForeachRangeNotInteger" xml:space="preserve">
    <value>LE3037: Тип '{0}' невозможно использовать в качестве границы диапазона, поскольку он не является целочисленным!</value>
  </data>
  <data name="ForeachRangeTypeMismatch" xml:space="preserve">
    <value>LE3038: Невозможно получить диапазон из выражений типов '{0}' и '{1}'!</value>
  </data>
  <data name="FunctionInvocationAmbiguous" xml:space="preserve">
    <value>LE3039: Найдено несколько подходящих переопределений функции '{0}'! Воспользуйтесь операцией приведения типов для указания конкретного переопределения!</value>
  </data>
  <data name="FunctionNotFound" xml:space="preserve">
    <value>LE3040: Не найдено ни одного переопределения функции '{0}', принимающей переданные аргументы!</value>
  </data>
  <data name="FunctionRedefinition" xml:space="preserve">
    <value>LE3041: Функция '{0}' с таким списком аргументов уже была объявлена!</value>
  </data>
  <data name="GenericArgCountMismatch" xml:space="preserve">
    <value>LE3042: Количество обобщенных аргументов не совпадает!</value>
  </data>
  <data name="GenericArgMismatch" xml:space="preserve">
    <value>LE3043: Для обобщенного аргумента '{0}' переданы несовпадающие значения: '{1}' и '{2}'!</value>
  </data>
  <data name="GenericArgsToNonGenericMethod" xml:space="preserve">
    <value>LE3044: Метод '{0}' не принимает обобщенных аргументов!</value>
  </data>
  <data name="GenericArgumentNotResolved" xml:space="preserve">
    <value>LE3045: Значение обобщенного аргумента '{0}' не может быть вычислено!</value>
  </data>
  <data name="GenericClassConstraintViolated" xml:space="preserve">
    <value>LE3046: Тип '{0}' не может быть использован как значение обобщенного аргумента '{1}' для типа '{2}', поскольку не является ссылочным типом!</value>
  </data>
  <data name="GenericConstructorConstraintViolated" xml:space="preserve">
    <value>LE3047: Тип '{0}' не может быть использован как значение обобщенного аргумента '{1}' для типа '{2}', поскольку не имеет конструктор по умолчанию!</value>
  </data>
  <data name="GenericHintMismatch" xml:space="preserve">
    <value>LE3048: Для обобщенного аргумента '{0}' был явно указан тип '{1}', но использование подразумевает тип '{2}'!</value>
  </data>
  <data name="GenericImplementationWrongType" xml:space="preserve">
    <value>LE3049: Невозможно вычислить значение обобщенного аргумента '{0}', используя тип '{1}'!</value>
  </data>
  <data name="GenericInheritanceConstraintViolated" xml:space="preserve">
    <value>LE3050: Тип '{0}' не может быть использован как значение обобщенного аргумента '{1}' для типа '{2}', поскольку не реализует класс или интерфейс '{3}'!</value>
  </data>
  <data name="GenericInterfaceMultipleImplementations" xml:space="preserve">
    <value>LE3051: Невозможно определить обобщенные аргументы интерфейса '{0}': тип '{1}' реализует несколько его переопределений!</value>
  </data>
  <data name="GenericInterfaceNotImplemented" xml:space="preserve">
    <value>LE3052: Тип '{0}' не реализует интерфейс '{1}'!</value>
  </data>
  <data name="GenericParameterNotFound" xml:space="preserve">
    <value>LE3053: Обобщенный аргумент '{0}' не был найден!</value>
  </data>
  <data name="GenericStructConstraintViolated" xml:space="preserve">
    <value>LE3054: Тип '{0}' не может быть использован как значение обобщенного аргумента '{1}' для типа '{2}', поскольку не является передаваемым по значению!</value>
  </data>
  <data name="GlobalPropertyNoGetter" xml:space="preserve">
    <value>LE3055: Невозможно получить значение глобального свойства '{0}'!</value>
  </data>
  <data name="GlobalPropertyNoSetter" xml:space="preserve">
    <value>LE3056: Невозможно задать значение глобального свойства '{0}'!</value>
  </data>
  <data name="GlobalPropertyTypeMismatch" xml:space="preserve">
    <value>LE3057: Невозможно присвоить глобальному свойству '{0}' значение типа '{1}'! Возможно, требуется явное приведение типа.</value>
  </data>
  <data name="IdentifierIsConstant" xml:space="preserve">
    <value>LE3058: '{0}' является константой и изменение ее значения запрещено!</value>
  </data>
  <data name="IdentifierNotFound" xml:space="preserve">
    <value>LE3059: Переменная или функция без параметров с названием '{0}' не найдена!</value>
  </data>
  <data name="IdentifierTypeMismatch" xml:space="preserve">
    <value>LE3060: Невозможно присвоить значение типа '{0}' переменной типа '{1}'! Возможно. требуется явное приведение типа.</value>
  </data>
  <data name="ImplicitCastImpossible" xml:space="preserve">
    <value>LE3061: Невозможно неявно привести выражение типа '{0}' к типу '{1}'!</value>
  </data>
  <data name="ImportIntoSaveableAssembly" xml:space="preserve">
    <value>LE3062: Сохраняемые сборки не поддерживают импорт!</value>
  </data>
  <data name="ImportUnsupportedMethod" xml:space="preserve">
    <value>LE3063: Только публичные, статические и не содержащие обобщенных аргументов методы могут быть импортированы!</value>
  </data>
  <data name="IndexAmbigious" xml:space="preserve">
    <value>LE3064: Индексатор не может быть однозначно определен! Подходят как минимум два переопределения:{3}{0}[{1}]{3}{0}[{2}]</value>
  </data>
  <data name="IndexerValuetypeRef" xml:space="preserve">
    <value>LE3065: Нельзя использовать индексатор типа '{0}' в качестве значения для ref-параметра, поскольку возвращаемый им тип '{1}' передается по значению!</value>
  </data>
  <data name="IndexGetterNotFound" xml:space="preserve">
    <value>LE3066: Тип '{0}' не содержит индексатора на чтение, который бы принимал индекс типа '{1}'!</value>
  </data>
  <data name="IndexSetterNotFound" xml:space="preserve">
    <value>LE3067: Тип '{0}' не содержит индексатора на запись, который бы принимал индекс типа '{1}'!</value>
  </data>
  <data name="LambdaReturnTypeUnknown" xml:space="preserve">
    <value>LE3071: Возвращаемый тип анонимной функции не может быть выведен! Воспользуйтесь операцией приведения типов.</value>
  </data>
  <data name="ListElementTypeMismatch" xml:space="preserve">
    <value>LE3072: Невозможно добавить объект типа '{0}' в List&lt;{1}&gt;!</value>
  </data>
  <data name="ListEmpty" xml:space="preserve">
    <value>LE3073: Инициализатор списка должен содержать хотя бы один элемент! Для создания пустых списков воспользуйтесь явным конструктором.</value>
  </data>
  <data name="ListTypeUnknown" xml:space="preserve">
    <value>LE3074: Тип списка не может быть выведен! Воспользуйтесь операцией приведения типов.</value>
  </data>
  <data name="Location" xml:space="preserve">
    <value>LE3075: Позиция: {0}</value>
  </data>
  <data name="LocationSpan" xml:space="preserve">
    <value>LE3076: Позиция: {0} ... {1}</value>
  </data>
  <data name="MethodRedefinition" xml:space="preserve">
    <value>LE3077: Метод '{0}' типа '{1}' с таким списком аргументов уже был объявлен!</value>
  </data>
  <data name="MethodRef" xml:space="preserve">
    <value>LE3078: Нельзя использовать метод в качестве значения для ref-параметра!</value>
  </data>
  <data name="OperatorBinaryTypesMismatch" xml:space="preserve">
    <value>LE3079: Невозможно применить оператор '{0}' к аргументам типов '{1}' и '{2}'!</value>
  </data>
  <data name="OperatorTypesSignednessMismatch" xml:space="preserve">
    <value>LE3080: Невозможно провести математическую операцию к числам разной знаковости!</value>
  </data>
  <data name="OperatorUnaryTypeMismatch" xml:space="preserve">
    <value>LE3081: Невозможно применить оператор '{0}' к аргументу типа '{1}'!</value>
  </data>
  <data name="ParameterlessConstructorParens" xml:space="preserve">
    <value>LE3082: Для вызова конструктора без параметров требуется указать пустые скобки!</value>
  </data>
  <data name="PropertyIdNoGetter" xml:space="preserve">
    <value>LE3083: Значение свойства #{0} не может быть получено!</value>
  </data>
  <data name="PropertyIdNoSetter" xml:space="preserve">
    <value>LE3084: Значение свойства #{0} не может быть задано!</value>
  </data>
  <data name="PropertyIdNotFound" xml:space="preserve">
    <value>LE3085: Свойство #{0} не найдено!</value>
  </data>
  <data name="PropertyImported" xml:space="preserve">
    <value>LE3086: Свойство '{0}' уже было импортировано!</value>
  </data>
  <data name="PropertyNoGetter" xml:space="preserve">
    <value>LE3087: Значение свойства '{0}.{1}' не может быть получено!</value>
  </data>
  <data name="PropertyNoSetter" xml:space="preserve">
    <value>LE3088: Значение свойства '{0}.{1}' не может быть задано!</value>
  </data>
  <data name="PropertyValuetypeRef" xml:space="preserve">
    <value>LE3089: Нельзя использовать свойство '{0}.{1}' в качестве значения для ref-параметра, поскольку возвращаемый им тип '{2}' передается по значению!</value>
  </data>
  <data name="PureFunctionReturnUnit" xml:space="preserve">
    <value>LE3090: Функция '{0}' не может быть чистой, поскольку не возвращает значения!</value>
  </data>
  <data name="PureFunctionTooManyArgs" xml:space="preserve">
    <value>LE3091: Функция '{0}' не может быть чистой, поскольку содержит больше 7 аргументов!</value>
  </data>
  <data name="ReferenceArgExpected" xml:space="preserve">
    <value>LE3092: Аргумент {0} требует ссылку типа '{1}'!</value>
  </data>
  <data name="ReferenceArgUnexpected" xml:space="preserve">
    <value>LE3093: Нельзя использовать ссылку в качестве значения не-ссылочного параметра!</value>
  </data>
  <data name="ReservedFunctionInvocation" xml:space="preserve">
    <value>LE3094: Невозможно вызвать функцию '{0}', поскольку она является зарезервированной!</value>
  </data>
  <data name="ReservedFunctionRedefinition" xml:space="preserve">
    <value>LE3095: Невозможно объявить функцию с именем '{0}', поскольку она является зарезервированной!</value>
  </data>
  <data name="ReturnTypeMismatch" xml:space="preserve">
    <value>LE3096: Функция типа '{0}' не может вернуть объект типа '{1}'!</value>
  </data>
  <data name="SafeModeIllegalType" xml:space="preserve">
    <value>LE3097: Растройки безопасного режима не позволяют использовать тип '{0}'!</value>
  </data>
  <data name="ThrowArgumentExpected" xml:space="preserve">
    <value>LE3098: Требуется выражение! Повторный выброс исключения допустим только в выражении catch.</value>
  </data>
  <data name="ThrowTypeNotException" xml:space="preserve">
    <value>LE3099: Тип '{0}' не может быть использован в выражении throw, поскольку он не наследуется от System.Exception!</value>
  </data>
  <data name="TupleNoArgs" xml:space="preserve">
    <value>LE3100: Кортеж должен содержать хотя бы один объект!</value>
  </data>
  <data name="TupleTooManyArgs" xml:space="preserve">
    <value>LE3101: Кортеж не может содержать больше 8 объектов! Воспользуйтесь структурой или вложенным кортежом.</value>
  </data>
  <data name="TypeAbstract" xml:space="preserve">
    <value>LE3102: Невозможно создать экземпляр абстрактного типа '{0}'!</value>
  </data>
  <data name="TypeArgumentsForNonMethod" xml:space="preserve">
    <value>LE3103: Невозможно применить обобщенные параметры к '{0}.{1}', потому что это не метод!</value>
  </data>
  <data name="TypeConstructorAmbiguos" xml:space="preserve">
    <value>LE3104: Тип '{0}' содержит несколько подходящих конструкторов! Воспользуйтесь операцией приведения типов .</value>
  </data>
  <data name="TypeConstructorNotFound" xml:space="preserve">
    <value>LE3105: Тип '{0}' не содержит конструктор с подходящим списком аргументов!</value>
  </data>
  <data name="TypeDefined" xml:space="preserve">
    <value>LE3106: Тип '{0}' уже объявлен!</value>
  </data>
  <data name="TypeIdentifierNotFound" xml:space="preserve">
    <value>LE3107: Тип '{0}' не содержит свойства, метода или поля под названием '{1}'!</value>
  </data>
  <data name="TypeIsAmbiguous" xml:space="preserve">
    <value>LE3109: Неоднозначное указание типа: тип '{0}' найден как минимум в двух пространствах имен:{5}{1} в сборке {2}{5}{3} в сборке {4}</value>
  </data>
  <data name="TypeMethodAmbiguous" xml:space="preserve">
    <value>LE3110: Тип '{0}' содержит несколько подходящих переопределений метода '{1}'! Укажите типы аргументов явно.</value>
  </data>
  <data name="TypeMethodInvocationAmbiguous" xml:space="preserve">
    <value>LE3111: Тип '{0}' содержит несколько подходящих переопределений метода '{1}'! Воспользуйтесь операцией приведения типов.</value>
  </data>
  <data name="TypeMethodNotFound" xml:space="preserve">
    <value>LE3112: Тип '{0}' не содержит метод '{1}' с подходящим списков аргументов! Соответствующий метод-расширение также не найден.</value>
  </data>
  <data name="TypeNotCallable" xml:space="preserve">
    <value>LE3113: Невозможно передать аргументы выражению типа '{0}', поскольку он не является функцией!</value>
  </data>
  <data name="TypeNotFound" xml:space="preserve">
    <value>LE3114: Тип '{0}' не найден!</value>
  </data>
  <data name="TypeNotImplicitlyBoolean" xml:space="preserve">
    <value>LE3115: Тип '{0}' нельзя использовать в булевом контексте!</value>
  </data>
  <data name="TypeNotIterable" xml:space="preserve">
    <value>LE3116: Тип '{0}' не является перечислимым!</value>
  </data>
  <data name="TypeNotNumeric" xml:space="preserve">
    <value>LE3117: Тип '{0}' не является числовым!</value>
  </data>
  <data name="TypeSettableIdentifierNotFound" xml:space="preserve">
    <value>LE3118: Тип '{0}' не содержит поля или свойства '{1}'!</value>
  </data>
  <data name="TypesIncomparable" xml:space="preserve">
    <value>LE3119: Невозможно сравнить объекты типов '{0}' и '{1}'!</value>
  </data>
  <data name="UnderscoreName" xml:space="preserve">
    <value>LE3121: Идентификатор '_' является зарезервированным и не может быть использован в названиях переменных, аргументов или любых других объявленных пользователем сущностей!</value>
  </data>
  <data name="VariableDefined" xml:space="preserve">
    <value>LE3123: Переменная '{0}' уже объявлена!</value>
  </data>
  <data name="VariableNotFound" xml:space="preserve">
    <value>LE3124: Переменная '{0}' не объявлена в данной области видимости!</value>
  </data>
  <data name="VoidTypeDefault" xml:space="preserve">
    <value>LE3127: Невозможно создать экземпляр типа Unit или void!</value>
  </data>
  <data name="TypeStaticMethodNotFound" xml:space="preserve">
    <value>LE3120: Тип '{0}' не содержит метод '{1}' с подходящим списком аргументов!</value>
  </data>
  <data name="FieldRedefinition" xml:space="preserve">
    <value>LE3036: Тип '{0}' уже содержит поле '{1}'!</value>
  </data>
  <data name="UnderscoreNameUsed" xml:space="preserve">
    <value>LE3122: Идентификатор '_' не может быть использовать в данном контексте!</value>
  </data>
  <data name="VariadicArgumentLambda" xml:space="preserve">
    <value>LE3125: Невозможно использовать модификатор '...' в анонимной функции!</value>
  </data>
  <data name="VariadicArgumentNotLast" xml:space="preserve">
    <value>LE3126: Аргумент c модификатором '...' должен быть последним в списке!</value>
  </data>
  <data name="LambdaArgTypeUnknown" xml:space="preserve">
    <value>LE3069: Тип аргумента '{0}' не может быть выведен автоматически! Пожалуйста, укажите тип явно!</value>
  </data>
  <data name="LambdaReturnTypeMismatch" xml:space="preserve">
    <value>LE3070: Анонимная функция используется в качестве делегата типа '{0}', но ее возвращаемый тип '{1}' несовместим с требуемым возвращаемым типом '{2}'!</value>
  </data>
  <data name="LambdaArgGenericsUnresolved" xml:space="preserve">
    <value>LE3068: Невозможно вычислить значения обобщенных параметров для типа аргумента '{0}'! Укажите тип аргумента явно.</value>
  </data>
  <data name="ArraySizeNotInt" xml:space="preserve">
    <value>LE3004: Невозможно использовать выражение типа '{0}' в качестве размера массива, поскольку оно не приводится к System.Int32!</value>
  </data>
  <data name="TypeInterface" xml:space="preserve">
    <value>LE3108: Невозможно создать экземпляр интерфейса '{0}'!</value>
  </data>
  <data name="ExpressionNotIDisposable" xml:space="preserve">
    <value>LE3033: Выражение типа '{0}' не может быть использовано в блоке 'using', поскольку не приводится к интерфейсу 'IDisposable'!</value>
  </data>
  <data name="NoCommonType" xml:space="preserve">
    <value>LE3134: Невозможно вывести общий тип для выражений, если хотя бы одно из них имеет тип 'Unit' или 'Void'!</value>
  </data>
  <data name="PatternNameDuplicated" xml:space="preserve">
    <value>LE3131: Шаблон содержит повторное объявление имени '{0}'!</value>
  </data>
  <data name="PatternNameSetMismatch" xml:space="preserve">
    <value>LE3132: Некорректное объявление имени в шаблоне: в некоторых альтернативах не объявлено имя '{0}'! Убедитесь, что во всех альтернативах список объявленных имен и их типы в точности совпадают.</value>
  </data>
  <data name="PatternNameTypeMismatch" xml:space="preserve">
    <value>LE3133: Некорректное объявление имени в шаблоне: типы для имени '{0}' не совпадают в альтернативных шаблонах (например, '{1}' и '{2}').</value>
  </data>
  <data name="PatternTupleTooFewArgs" xml:space="preserve">
    <value>LE3129: Шаблон кортежа должен содержать хотя бы 1 элемент!</value>
  </data>
  <data name="PatternTupleTooManyArgs" xml:space="preserve">
    <value>LE3128: Шаблон кортежа не может содержать более 7 элементов!</value>
  </data>
  <data name="PatternTypeMismatch" xml:space="preserve">
    <value>LE3130: Шаблон не может быть применен к типу '{0}', поскольку он несовместим с ожидаемым типом '{1}'!</value>
  </data>
  <data name="PatternArraySubsequences" xml:space="preserve">
    <value>LE3135: Шаблон массива не может содержать больше одной вложенной последовательности, объявленной с помощью многоточия!</value>
  </data>
  <data name="PatternNotValidRecord" xml:space="preserve">
    <value>LE3139: Тип '{0}' должен быть объявлен как запись, чтобы использовать его в данном шаблоне!</value>
  </data>
  <data name="PatternNotValidType" xml:space="preserve">
    <value>LE3138: Тип '{0}' должен быть объявлен в скрипте, чтобы использовать его в данном шаблоне!</value>
  </data>
  <data name="PatternRangeNotNumeric" xml:space="preserve">
    <value>LE3141: Пределы диапазона должны быть числовыми константами!</value>
  </data>
  <data name="PatternRecordNoField" xml:space="preserve">
    <value>LE3140: Запись '{0}' не содержит поля под названием '{1}'!</value>
  </data>
  <data name="PatternTypeMatchImpossible" xml:space="preserve">
    <value>LE3136: Выражение типа '{0}' никогда не может принимать значения типа '{1}'!</value>
  </data>
  <data name="PatternTypeNoTag" xml:space="preserve">
    <value>LE3140: Тип '{0}' не содержит метку!</value>
  </data>
  <data name="PatternUnreachable" xml:space="preserve">
    <value>LE3137: Шаблон никогда не будет выполнен, поскольку предыдущий перехватывает все возможные значения!</value>
  </data>
  <data name="PatternSubsequenceLocation" xml:space="preserve">
    <value>LE3142: Вложенная последовательность в IEnumerable должна быть последним элементом шаблона!</value>
  </data>
  <data name="PatternRecordFieldDuplicated" xml:space="preserve">
    <value>LE3143: Повторно указан шаблон для поля '{0}'!</value>
  </data>
  <data name="RegexConverterTypeIncompatible" xml:space="preserve">
    <value>LE3147: Тип '{0}' не может быть использован в качестве конвертера, поскольку не содержит метода с сигнатурой Parse(string)!</value>
  </data>
  <data name="RegexConverterTypeNotFound" xml:space="preserve">
    <value>LE3146: Тип-конвертер '{0}' не найден!</value>
  </data>
  <data name="RegexDuplicateModifier" xml:space="preserve">
    <value>LE3145: Дважды использован модификатор '{0}'!</value>
  </data>
  <data name="RegexSyntaxError" xml:space="preserve">
    <value>LE3148: Синтаксическая ошибка в регулярном выражении!</value>
  </data>
  <data name="RegexUnknownModifier" xml:space="preserve">
    <value>LE3144: Неизвестный модификатор '{0}'!</value>
  </data>
  <data name="EventAsExpr" xml:space="preserve">
    <value>LE3149: Событие не может быть использовано в выражении!</value>
  </data>
</root>